I'll provide a detailed step-by-step implementation for saving and deleting chat checkpoints using langgraph4j-postgres-saver with Spring Boot and Spring AI.

Step 1: Add Dependencies
First, add the necessary dependencies to your pom.xml:

<dependencies>
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring AI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-core</artifactId>
    </dependency>
    
    <!-- LangGraph4j -->
    <dependency>
        <groupId>com.github.tjake</groupId>
        <artifactId>langgraph4j</artifactId>
        <version>1.6.3</version>
    </dependency>
    
    <!-- LangGraph4j Postgres Saver -->
    <dependency>
        <groupId>com.github.tjake</groupId>
        <artifactId>langgraph4j-postgres-saver</artifactId>
        <version>1.6.3</version>
    </dependency>
    
    <!-- PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <runtime>true</runtime>
    </dependency>
    
    <!-- Spring Data JPA for easier database operations -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
</dependencies>


Step 2: Configure Database Connection
Add database configuration to your application.properties or application.yml:

# PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/chat_db
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

Step 3: Create Configuration Class
Create a configuration class to set up the PostgresSaver bean:

package com.example.chatapp.config;

import com.github.tjake.langgraph4j.postgres.PostgresSaver;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class LangGraphConfig {

    @Bean
    public PostgresSaver postgresSaver(DataSource dataSource) {
        return new PostgresSaver(dataSource);
    }
}

Step 4: Create Checkpoint Model
Create a model class to represent the checkpoint data:

package com.example.chatapp.model;

import java.time.Instant;
import java.util.Map;

public class ChatCheckpoint {
    private String threadId;
    private String checkpointId;
    private Map<String, Object> context;
    private Instant createdAt;

    // Constructors
    public ChatCheckpoint() {}

    public ChatCheckpoint(String threadId, String checkpointId, Map<String, Object> context) {
        this.threadId = threadId;
        this.checkpointId = checkpointId;
        this.context = context;
        this.createdAt = Instant.now();
    }

    // Getters and Setters
    public String getThreadId() {
        return threadId;
    }

    public void setThreadId(String threadId) {
        this.threadId = threadId;
    }

    public String getCheckpointId() {
        return checkpointId;
    }

    public void setCheckpointId(String checkpointId) {
        this.checkpointId = checkpointId;
    }

    public Map<String, Object> getContext() {
        return context;
    }

    public void setContext(Map<String, Object> context) {
        this.context = context;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }
}


Step 5: Create Service Class
Create a service class to handle checkpoint operations:

package com.example.chatapp.service;

import com.example.chatapp.model.ChatCheckpoint;
import com.github.tjake.langgraph4j.postgres.PostgresSaver;
import com.github.tjake.langgraph4j.state.Checkpoint;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Service
public class ChatCheckpointService {

    private final PostgresSaver postgresSaver;

    public ChatCheckpointService(PostgresSaver postgresSaver) {
        this.postgresSaver = postgresSaver;
    }

    /**
     * Save a chat checkpoint with context
     * @param threadId The thread ID for the chat session
     * @param context The context data to save
     * @return The saved checkpoint
     */
    public ChatCheckpoint saveCheckpoint(String threadId, Map<String, Object> context) {
        // Generate a unique checkpoint ID
        String checkpointId = UUID.randomUUID().toString();
        
        // Create the checkpoint object
        Checkpoint checkpoint = Checkpoint.builder()
            .threadId(threadId)
            .checkpointId(checkpointId)
            .checkpointNs("chat")  // Namespace for chat checkpoints
            .values(context)
            .build();
        
        // Save to PostgreSQL
        postgresSaver.put(checkpoint);
        
        // Return the checkpoint model
        return new ChatCheckpoint(threadId, checkpointId, context);
    }

    /**
     * Load a chat checkpoint by thread ID
     * @param threadId The thread ID to load
     * @return The checkpoint data or empty map if not found
     */
    public Map<String, Object> loadCheckpoint(String threadId) {
        Optional<Checkpoint> checkpoint = postgresSaver.get(threadId, null);
        return checkpoint.map(Checkpoint::values).orElse(new HashMap<>());
    }

    /**
     * Load a specific checkpoint by thread ID and checkpoint ID
     * @param threadId The thread ID
     * @param checkpointId The specific checkpoint ID
     * @return The checkpoint data or empty map if not found
     */
    public Map<String, Object> loadCheckpoint(String threadId, String checkpointId) {
        Optional<Checkpoint> checkpoint = postgresSaver.get(threadId, checkpointId);
        return checkpoint.map(Checkpoint::values).orElse(new HashMap<>());
    }

    /**
     * Delete all checkpoints for a thread
     * @param threadId The thread ID to delete checkpoints for
     */
    public void deleteCheckpoints(String threadId) {
        postgresSaver.delete(threadId);
    }

    /**
     * Delete a specific checkpoint
     * @param threadId The thread ID
     * @param checkpointId The specific checkpoint ID to delete
     */
    public void deleteCheckpoint(String threadId, String checkpointId) {
        postgresSaver.delete(threadId, checkpointId);
    }

    /**
     * Check if a checkpoint exists
     * @param threadId The thread ID
     * @param checkpointId The checkpoint ID (optional)
     * @return true if exists, false otherwise
     */
    public boolean checkpointExists(String threadId, String checkpointId) {
        if (checkpointId == null) {
            return postgresSaver.get(threadId, null).isPresent();
        } else {
            return postgresSaver.get(threadId, checkpointId).isPresent();
        }
    }
}


Step 6: Create REST Controller
Create a REST controller to expose the checkpoint operations via HTTP endpoints:

package com.example.chatapp.controller;

import com.example.chatapp.model.ChatCheckpoint;
import com.example.chatapp.service.ChatCheckpointService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/chat/checkpoints")
public class ChatCheckpointController {

    private final ChatCheckpointService checkpointService;

    public ChatCheckpointController(ChatCheckpointService checkpointService) {
        this.checkpointService = checkpointService;
    }

    /**
     * Save a chat checkpoint
     * POST /api/chat/checkpoints
     * Body: {"threadId": "thread123", "context": {"messages": [...], "state": {...}}}
     */
    @PostMapping
    public ResponseEntity<ChatCheckpoint> saveCheckpoint(@RequestBody Map<String, Object> request) {
        String threadId = (String) request.get("threadId");
        @SuppressWarnings("unchecked")
        Map<String, Object> context = (Map<String, Object>) request.get("context");
        
        if (threadId == null || context == null) {
            return ResponseEntity.badRequest().build();
        }
        
        ChatCheckpoint saved = checkpointService.saveCheckpoint(threadId, context);
        return ResponseEntity.ok(saved);
    }

    /**
     * Load a chat checkpoint
     * GET /api/chat/checkpoints/{threadId}
     */
    @GetMapping("/{threadId}")
    public ResponseEntity<Map<String, Object>> loadCheckpoint(@PathVariable String threadId) {
        Map<String, Object> context = checkpointService.loadCheckpoint(threadId);
        if (context.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(context);
    }

    /**
     * Load a specific checkpoint
     * GET /api/chat/checkpoints/{threadId}/{checkpointId}
     */
    @GetMapping("/{threadId}/{checkpointId}")
    public ResponseEntity<Map<String, Object>> loadCheckpoint(
            @PathVariable String threadId, 
            @PathVariable String checkpointId) {
        Map<String, Object> context = checkpointService.loadCheckpoint(threadId, checkpointId);
        if (context.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(context);
    }

    /**
     * Delete all checkpoints for a thread
     * DELETE /api/chat/checkpoints/{threadId}
     */
    @DeleteMapping("/{threadId}")
    public ResponseEntity<Void> deleteCheckpoints(@PathVariable String threadId) {
        checkpointService.deleteCheckpoints(threadId);
        return ResponseEntity.ok().build();
    }

    /**
     * Delete a specific checkpoint
     * DELETE /api/chat/checkpoints/{threadId}/{checkpointId}
     */
    @DeleteMapping("/{threadId}/{checkpointId}")
    public ResponseEntity<Void> deleteCheckpoint(
            @PathVariable String threadId, 
            @PathVariable String checkpointId) {
        checkpointService.deleteCheckpoint(threadId, checkpointId);
        return ResponseEntity.ok().build();
    }

    /**
     * Check if checkpoint exists
     * HEAD /api/chat/checkpoints/{threadId}
     * or HEAD /api/chat/checkpoints/{threadId}/{checkpointId}
     */
    @RequestMapping(value = "/{threadId}", method = RequestMethod.HEAD)
    public ResponseEntity<Void> checkpointExists(@PathVariable String threadId) {
        boolean exists = checkpointService.checkpointExists(threadId, null);
        return exists ? ResponseEntity.ok().build() : ResponseEntity.notFound().build();
    }

    @RequestMapping(value = "/{threadId}/{checkpointId}", method = RequestMethod.HEAD)
    public ResponseEntity<Void> checkpointExists(
            @PathVariable String threadId, 
            @PathVariable String checkpointId) {
        boolean exists = checkpointService.checkpointExists(threadId, checkpointId);
        return exists ? ResponseEntity.ok().build() : ResponseEntity.notFound().build();
    }
}


Step 7: Create Main Application Class
Ensure your main Spring Boot application class is set up:

package com.example.chatapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ChatApplication {

    public static void main(String[] args) {
        SpringApplication.run(ChatApplication.class, args);
    }
}

Step 8: Usage Examples
Here are examples of how to use the API:

Save a Checkpoint
curl -X POST http://localhost:8080/api/chat/checkpoints \
  -H "Content-Type: application/json" \
  -d '{
    "threadId": "chat-session-123",
    "context": {
      "messages": [
        {"role": "user", "content": "Hello"},
        {"role": "assistant", "content": "Hi there!"}
      ],
      "currentState": "waiting_for_input"
    }
  }'

Load a Checkpoint
curl http://localhost:8080/api/chat/checkpoints/chat-session-123

Delete Checkpoints
curl -X DELETE http://localhost:8080/api/chat/checkpoints/chat-session-123

Step 9: Integration with Spring AI
To integrate with Spring AI chat functionality:

@Service
public class ChatService {

    private final ChatCheckpointService checkpointService;
    private final ChatClient chatClient;

    public ChatService(ChatCheckpointService checkpointService, ChatClient chatClient) {
        this.checkpointService = checkpointService;
        this.chatClient = chatClient;
    }

    public String processMessage(String threadId, String userMessage) {
        // Load existing context
        Map<String, Object> context = checkpointService.loadCheckpoint(threadId);
        
        // Add new message to context
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> messages = (List<Map<String, Object>>) context.getOrDefault("messages", new ArrayList<>());
        messages.add(Map.of("role", "user", "content", userMessage));
        
        // Generate AI response
        String aiResponse = chatClient.call(userMessage);
        messages.add(Map.of("role", "assistant", "content", aiResponse));
        
        // Update context
        context.put("messages", messages);
        
        // Save checkpoint
        checkpointService.saveCheckpoint(threadId, context);
        
        return aiResponse;
    }
}